routes:
// message routes.
Route::get('/manufacturer/chats', [ChatsController::class, 'chatRecords'])->middleware('manufacturer');
Route::get('/wholesaler/chats', [ChatsController::class, 'chatRecords'])->middleware('wholesaler');
Route::get('/wholesaler/chats/{manufacturer_uid}', [ChatsController::class, 'chatWithSpecManufacturer'])->middleware('wholesaler');

Route::post('/fetch-chats', [ChatsController::class, 'fetchChats'])->middleware('manufacturer_or_wholesaler');
Route::post('/send-text-message', [ChatsController::class, 'sendMessage'])->middleware('manufacturer_or_wholesaler');
Route::post('/send-file-message', [ChatsController::class, 'sendFileMessage'])->middleware('manufacturer_or_wholesaler');
Route::post('/get-user-chat-info', [ChatsController::class, 'getUserChatInfo'])->middleware('manufacturer_or_wholesaler');
Route::post('/get-unread-count', [ChatsController::class, 'getUnreadCount'])->middleware('manufacturer_or_wholesaler');
Route::post('/update-last-active', [ChatsController::class, 'updateLastActive'])->middleware('manufacturer_or_wholesaler');
Route::post('/get-chat-list-item', [ChatsController::class, 'getChatListItem'])->middleware('manufacturer_or_wholesaler');
Route::post('/mark-messages-seen', [ChatsController::class, 'markMessagesAsSeen'])->middleware('manufacturer_or_wholesaler');
Route::post('/update-last-active', [ChatsController::class, 'updateLastActive'])->middleware('manufacturer_or_wholesaler');


Controller:
<?php

namespace App\Http\Controllers;

use App\Models\Chat;
use App\Models\Manufacturer;
use App\Models\Wholesaler;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Intervention\Image\Laravel\Facades\Image;
use GuzzleHttp\Client;
use Exception;

class ChatsController extends Controller
{
    private function notifyWebSocketServer($data)
    {
        try {
            $client = new Client([
                'timeout' => 2.0,
                'connect_timeout' => 1.0
            ]);

            $client->post('http://localhost:3000/api/notify', [
                'json' => $data,
                'headers' => [
                    'Content-Type' => 'application/json',
                    'Accept' => 'application/json'
                ]
            ]);

            Log::info('WebSocket notification sent', ['type' => $data['type']]);
        } catch (Exception $e) {
            Log::error('Failed to notify WebSocket server: ' . $e->getMessage());
        }
    }

    public function chatRecords()
    {
        if (Auth::guard('wholesaler')->check()) {
            $sending_to_type = 'manufacturer';
            $chat_with = Manufacturer::all();
            $user_uid = Auth::guard('wholesaler')->user()->wholesaler_uid;
            $user_uid_type = 'manufacturer_uid';
        } else {
            $sending_to_type = 'wholesaler';
            $chat_with = Wholesaler::all();
            $user_uid = Auth::guard('manufacturer')->user()->manufacturer_uid;
            $user_uid_type = 'wholesaler_uid';
        }

        $spec_manufacturer = '';
        $online_status = 'online';
        return view('chats.messaging', compact('chat_with', 'sending_to_type', 'user_uid', 'user_uid_type', 'spec_manufacturer', 'online_status'));
    }




    public function chatWithSpecManufacturer($manufacturer_uid)
    {
        if (Auth::guard('wholesaler')->check()) {
            $sending_to_type = 'manufacturer';
            $chat_with = Manufacturer::all();
            $user_uid = Auth::guard('wholesaler')->user()->wholesaler_uid;
            // FIX: Query manufacturer table for manufacturer's last_active_time
            $last_active_time = Manufacturer::where('manufacturer_uid', $manufacturer_uid)->value('last_active_time');
            $user_uid_type = 'manufacturer_uid';
        } else {
            $sending_to_type = 'wholesaler';
            $chat_with = Wholesaler::all();
            $user_uid = Auth::guard('manufacturer')->user()->manufacturer_uid;
            // FIX: Query wholesaler table for wholesaler's last_active_time
            $last_active_time = Wholesaler::where('wholesaler_uid', $manufacturer_uid)->value('last_active_time');
            $user_uid_type = 'wholesaler_uid';
        }

        $spec_manufacturer = Manufacturer::where('manufacturer_uid', $manufacturer_uid)->first();
        if (!$spec_manufacturer) {
            return redirect()->route('wholesaler.chats')->with('error', 'Manufacturer not found');
        }

        $is_online = false;
        if ($last_active_time) {
            try {
                $is_online = \Carbon\Carbon::now()->diffInMinutes(\Carbon\Carbon::parse($last_active_time)) <= 15;
            } catch (\Exception $e) {
                $is_online = false;
            }
        }

        $online_status = $is_online ? 'online' : 'offline';

        return view('chats.messaging', compact('chat_with', 'sending_to_type', 'user_uid', 'user_uid_type', 'spec_manufacturer', 'online_status'));
    }






    public function fetchChats(Request $request)
    {
        try {
            $receiver_id = $request['sending_to'];
            if (Auth::guard('wholesaler')->check()) {
                $sender_id = Auth::guard('wholesaler')->user()->wholesaler_uid;
                $last_active_time = Wholesaler::where('wholesaler_uid', $sender_id)->value('last_active_time');
            } else {
                $sender_id = Auth::guard('manufacturer')->user()->manufacturer_uid;
                $last_active_time = Manufacturer::where('manufacturer_uid', $sender_id)->value('last_active_time');
            }

            $is_online = false;
            if ($last_active_time) {
                try {
                    $is_online = \Carbon\Carbon::now()->diffInMinutes(\Carbon\Carbon::parse($last_active_time)) <= 15;
                } catch (\Exception $e) {
                    $is_online = false;
                }
            }

            $online_status = $is_online ? 'online' : 'offline';

            $messages = Chat::where(function ($query) use ($sender_id, $receiver_id) {
                $query->where('sent_by', $sender_id)
                    ->where('sent_to', $receiver_id);
            })->orWhere(function ($query) use ($sender_id, $receiver_id) {
                $query->where('sent_by', $receiver_id)
                    ->where('sent_to', $sender_id);
            })->orderBy('created_at', 'asc')->get();

            // Get ALL unseen message IDs from this sender
            $allUnseenMessageIds = Chat::where('sent_to', $sender_id)
                ->where('sent_by', $receiver_id)
                ->where('seen', 0)
                ->pluck('message_uid')
                ->toArray();

            // Mark ALL messages from this sender as seen in database
            if (!empty($allUnseenMessageIds)) {
                Chat::where('sent_to', $sender_id)
                    ->where('sent_by', $receiver_id)
                    ->where('seen', 0)
                    ->update(['seen' => 1]);

                // Notify WebSocket about ALL messages being seen
                $this->notifyWebSocketServer([
                    'type' => 'messages_marked_seen',
                    'senderId' => $sender_id,
                    'receiverId' => $receiver_id,
                    'messageUids' => $allUnseenMessageIds
                ]);
            }

            return response()->json(['messages' => $messages, 'online_status' => $online_status], 200);
        } catch (\Exception $e) {
            Log::error('Error fetching chats: ' . $e->getMessage());
            return response()->json([
                'status' => 'error',
                'message' => 'Failed to fetch messages'
            ], 500);
        }
    }



    public function sendMessage(Request $request)
    {
        $sending_to = $request['sending_to'];
        $message_box = $request['message_box'];

        if (Auth::guard('wholesaler')->check()) {
            $sent_by = Auth::guard('wholesaler')->user()->wholesaler_uid;
        } else {
            $sent_by = Auth::guard('manufacturer')->user()->manufacturer_uid;
        }

        $message_uid = uniqid('msg_');

        // Save to database
        $chat = Chat::create([
            'message_uid' => $message_uid,
            'sent_by' => $sent_by,
            'sent_to' => $sending_to,
            'seen' => 0, // Initially unseen
            'message_type' => 'text',
            'main_message' => $message_box,
        ]);

        // After successful database save, notify WebSocket server
        if ($chat) {
            $this->notifyWebSocketServer([
                'type' => 'new_text_message',
                'senderId' => $sent_by,
                'receiverId' => $sending_to,
                'message' => $message_box,
                'messageUid' => $message_uid,
                'timestamp' => $chat->created_at->toISOString()
            ]);
        }

        return response()->json([
            'status' => 'success',
            'message_uid' => $message_uid,
            'timestamp' => $chat->created_at->toISOString()
        ], 200);
    }

    public function sendFileMessage(Request $request)
    {
        $request->validate([
            'file' => 'required|file|mimes:jpg,jpeg,png,gif,pdf,doc,docx,ppt,pptx|max:20480',
        ]);

        $sending_to = $request['sending_to'];
        $message_text = $request['message_text'] ?? '';

        if (Auth::guard('wholesaler')->check()) {
            $sent_by = Auth::guard('wholesaler')->user()->wholesaler_uid;
            $user_folder = 'wholesaler_' . $sent_by;
        } else {
            $sent_by = Auth::guard('manufacturer')->user()->manufacturer_uid;
            $user_folder = 'manufacturer_' . $sent_by;
        }

        $file = $request->file('file');
        $originalName = $file->getClientOriginalName();
        $fileType = $file->getMimeType();

        $directory = "chat_documents/{$user_folder}";
        if (!Storage::disk('public')->exists($directory)) {
            Storage::disk('public')->makeDirectory($directory);
        }

        $filename = uniqid() . '_' . time() . '.' . $file->getClientOriginalExtension();
        $filePath = "{$directory}/{$filename}";

        if (str_starts_with($fileType, 'image/')) {
            try {
                $image = Image::read($file->getPathname());
                $image->scaleDown(width: 1200);
                $encodedImage = $image->toJpeg(40);
                Storage::disk('public')->put($filePath, $encodedImage);
            } catch (\Exception $e) {
                Log::error('Image compression failed: ' . $e->getMessage());
                Storage::disk('public')->put($filePath, file_get_contents($file));
            }
        } else {
            Storage::disk('public')->put($filePath, file_get_contents($file));
        }

        $fileData = [
            'file_url' => asset("storage/{$filePath}"),
            'file_path' => $filePath,
            'original_name' => $originalName,
            'file_type' => $fileType,
            'file_size' => Storage::disk('public')->size($filePath),
        ];

        $messageData = [
            'file_data' => $fileData,
            'message_text' => $message_text
        ];

        $message_uid = uniqid('file_');

        // Save to database
        $chat = Chat::create([
            'message_uid' => $message_uid,
            'sent_by' => $sent_by,
            'sent_to' => $sending_to,
            'seen' => 0, // Initially unseen
            'message_type' => 'file',
            'main_message' => json_encode($messageData),
        ]);

        // After successful database save, notify WebSocket server
        if ($chat) {
            $this->notifyWebSocketServer([
                'type' => 'new_file_message',
                'senderId' => $sent_by,
                'receiverId' => $sending_to,
                'fileData' => $fileData,
                'messageText' => $message_text,
                'messageUid' => $message_uid,
                'timestamp' => $chat->created_at->toISOString()
            ]);
        }

        return response()->json([
            'status' => 'success',
            'file_data' => $fileData,
            'message_text' => $message_text,
            'message_uid' => $message_uid,
            'timestamp' => $chat->created_at->toISOString()
        ], 200);
    }



    public function markMessagesAsSeen(Request $request)
    {
        $messageUids = $request->input('message_uids', []);
        $senderId = $request->input('sender_id');

        if (Auth::guard('wholesaler')->check()) {
            $currentUser = Auth::guard('wholesaler')->user()->wholesaler_uid;
        } else {
            $currentUser = Auth::guard('manufacturer')->user()->manufacturer_uid;
        }

        // If specific message UIDs are provided, mark only those as seen
        if (!empty($messageUids)) {
            Chat::whereIn('message_uid', $messageUids)
                ->where('sent_to', $currentUser)
                ->where('sent_by', $senderId)
                ->where('seen', 0)
                ->update(['seen' => 1]);
        }
        // If no specific UIDs, mark ALL unseen messages from this sender as seen
        else {
            $allUnseenMessageIds = Chat::where('sent_to', $currentUser)
                ->where('sent_by', $senderId)
                ->where('seen', 0)
                ->pluck('message_uid')
                ->toArray();

            Chat::where('sent_to', $currentUser)
                ->where('sent_by', $senderId)
                ->where('seen', 0)
                ->update(['seen' => 1]);

            $messageUids = $allUnseenMessageIds;
        }

        // Notify WebSocket about messages being seen
        if (!empty($messageUids)) {
            $this->notifyWebSocketServer([
                'type' => 'messages_marked_seen',
                'senderId' => $currentUser,
                'receiverId' => $senderId,
                'messageUids' => $messageUids
            ]);
        }

        return response()->json(['status' => 'success']);
    }


    public function getUserChatInfo(Request $request)
    {
        $userId = $request->input('user_id');
        $sendingToType = $request->input('sending_to_type');

        try {
            if ($sendingToType === 'manufacturer') {
                $user = Manufacturer::where('manufacturer_uid', $userId)->first();
                if ($user) {
                    return response()->json([
                        'status' => 'success',
                        'user' => [
                            'id' => $user->manufacturer_uid,
                            'name' => $user->company_name_en,
                            'profile_picture' => $user->company_logo ? asset($user->company_logo) : 'https://ui-avatars.com/api/?name=' . urlencode($user->company_name_en) . '&background=3b82f6&color=fff'
                        ]
                    ]);
                }
            } else {
                $user = Wholesaler::where('wholesaler_uid', $userId)->first();
                if ($user) {
                    return response()->json([
                        'status' => 'success',
                        'user' => [
                            'id' => $user->wholesaler_uid,
                            'name' => $user->company_name,
                            'profile_picture' => $user->profile_picture ? asset($user->profile_picture) : 'https://ui-avatars.com/api/?name=' . urlencode($user->company_name) . '&background=3b82f6&color=fff'
                        ]
                    ]);
                }
            }

            return response()->json([
                'status' => 'error',
                'message' => 'User not found'
            ], 404);
        } catch (\Exception $e) {
            return response()->json([
                'status' => 'error',
                'message' => 'Error fetching user info'
            ], 500);
        }
    }

    public function getUnreadCount(Request $request)
    {
        $userId = $request->input('user_id');

        if (Auth::guard('wholesaler')->check()) {
            $currentUser = Auth::guard('wholesaler')->user()->wholesaler_uid;
        } else {
            $currentUser = Auth::guard('manufacturer')->user()->manufacturer_uid;
        }

        $count = Chat::where('sent_to', $currentUser)
            ->where('sent_by', $userId)
            ->where('seen', 0)
            ->count();

        return response()->json(['count' => $count]);
    }





    public function updateLastActive(Request $request)
    {
        try {
            if (Auth::guard('wholesaler')->check()) {
                $userId = Auth::guard('wholesaler')->user()->wholesaler_uid;
                Wholesaler::where('wholesaler_uid', $userId)
                    ->update(['last_active_time' => now()]);
            } else {
                $userId = Auth::guard('manufacturer')->user()->manufacturer_uid;
                Manufacturer::where('manufacturer_uid', $userId)
                    ->update(['last_active_time' => now()]);
            }

            // Notify WebSocket server about activity
            $this->notifyWebSocketServer([
                'type' => 'user_activity',
                'userId' => $userId,
                'timestamp' => now()->toISOString()
            ]);

            return response()->json(['status' => 'success']);
        } catch (\Exception $e) {
            Log::error('Error updating last active: ' . $e->getMessage());
            return response()->json([
                'status' => 'error',
                'message' => 'Failed to update last active time'
            ], 500);
        }
    }






    public function getChatListItem(Request $request)
    {
        $userId = $request->input('user_id');
        $sendingToType = $request->input('sending_to_type');
        $currentUserId = $request->input('current_user_id');

        try {
            if ($sendingToType === 'manufacturer') {
                $user = Manufacturer::where('manufacturer_uid', $userId)->first();
                if ($user) {
                    // Get last message
                    $lastMessage = Chat::where(function ($query) use ($currentUserId, $userId) {
                        $query->where(function ($q) use ($currentUserId, $userId) {
                            $q->where('sent_by', $currentUserId)->where('sent_to', $userId);
                        })->orWhere(function ($q) use ($currentUserId, $userId) {
                            $q->where('sent_by', $userId)->where('sent_to', $currentUserId);
                        });
                    })->latest()->first();

                    // Get unseen count
                    $unseenCount = Chat::where('sent_to', $currentUserId)
                        ->where('sent_by', $userId)
                        ->where('seen', 0)
                        ->count();

                    // Format last message
                    $lastMessageTime = $lastMessage ? $lastMessage->created_at->diffForHumans(null, true, true) : '';

                    if ($lastMessage) {
                        if ($lastMessage->message_type === 'text') {
                            $lastMessageText = \Illuminate\Support\Str::limit($lastMessage->main_message, 40);
                            $messageIcon = '';
                        } else {
                            $isSent = $lastMessage->sent_by === $currentUserId;
                            $messageIcon = '<i class="fas fa-file-alt"></i>';
                            $lastMessageText = $isSent ? 'File sent' : 'File received';
                        }
                    } else {
                        $lastMessageText = 'No messages yet';
                        $messageIcon = '';
                    }

                    return response()->json([
                        'status' => 'success',
                        'user' => [
                            'id' => $user->manufacturer_uid,
                            'name' => $user->company_name_en,
                            'profile_picture' => $user->company_logo ? asset($user->company_logo) : 'https://ui-avatars.com/api/?name=' . urlencode($user->company_name_en) . '&background=3b82f6&color=fff',
                            'last_message' => $lastMessageText,
                            'message_icon' => $messageIcon,
                            'last_message_time' => $lastMessageTime,
                            'unseen_count' => $unseenCount
                        ]
                    ]);
                }
            } else {
                $user = Wholesaler::where('wholesaler_uid', $userId)->first();
                if ($user) {
                    // Same logic for wholesaler
                    $lastMessage = Chat::where(function ($query) use ($currentUserId, $userId) {
                        $query->where(function ($q) use ($currentUserId, $userId) {
                            $q->where('sent_by', $currentUserId)->where('sent_to', $userId);
                        })->orWhere(function ($q) use ($currentUserId, $userId) {
                            $q->where('sent_by', $userId)->where('sent_to', $currentUserId);
                        });
                    })->latest()->first();

                    $unseenCount = Chat::where('sent_to', $currentUserId)
                        ->where('sent_by', $userId)
                        ->where('seen', 0)
                        ->count();

                    $lastMessageTime = $lastMessage ? $lastMessage->created_at->diffForHumans(null, true, true) : '';

                    if ($lastMessage) {
                        if ($lastMessage->message_type === 'text') {
                            $lastMessageText = \Illuminate\Support\Str::limit($lastMessage->main_message, 40);
                            $messageIcon = '';
                        } else {
                            $isSent = $lastMessage->sent_by === $currentUserId;
                            $messageIcon = '<i class="fas fa-file-alt"></i>';
                            $lastMessageText = $isSent ? 'File sent' : 'File received';
                        }
                    } else {
                        $lastMessageText = 'No messages yet';
                        $messageIcon = '';
                    }

                    return response()->json([
                        'status' => 'success',
                        'user' => [
                            'id' => $user->wholesaler_uid,
                            'name' => $user->company_name,
                            'profile_picture' => $user->profile_picture ? asset($user->profile_picture) : 'https://ui-avatars.com/api/?name=' . urlencode($user->company_name) . '&background=3b82f6&color=fff',
                            'last_message' => $lastMessageText,
                            'message_icon' => $messageIcon,
                            'last_message_time' => $lastMessageTime,
                            'unseen_count' => $unseenCount
                        ]
                    ]);
                }
            }

            return response()->json([
                'status' => 'error',
                'message' => 'User not found'
            ], 404);
        } catch (\Exception $e) {
            return response()->json([
                'status' => 'error',
                'message' => 'Error fetching user info'
            ], 500);
        }
    }
}



messaging.blade.php:
<!doctype html>
<html lang="en" class="main_html">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    @if (Auth::guard('wholesaler')->check())
        <meta name="user-type" content="wholesaler">
    @else
        <meta name="user-type" content="manufacturer">
    @endif


    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="icon" href="{{ $website_icon }}" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>


    @vite('resources/css/app.css')
    {{-- <link rel="stylesheet" href="/assets/css/tailwind.css"> --}}
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/chats.css">

    <title>{{ $brandname }} â€” Your Chat Records </title>
</head>


<body class="bg-white dark:bg-gray-950">

    <div class="chat_system_full_area">
        <div class="h-screen flex flex-col">
            <!-- Header -->
            <div
                class="bg-white border-b border-gray-200 px-6 py-4 lg:block chat_header  @if ($spec_manufacturer != '') hidden @endif">
                <div class="flex items-center gap-2">
                    <h1 class="text-2xl font-bold text-gray-900">
                        <a href="/" class="hover:text-blue-600 transition-colors">Home</a>
                        <span class="text-gray-500">/</span>
                        <span>Chats</span>
                    </h1>
                </div>
                <p class="text-sm text-gray-600">Your chat history with {{ $sending_to_type }}s</p>
            </div>

            <!-- Chat Container -->
            <div class="grid lg:flex-1 lg:flex overflow-hidden">
                <!-- Left Sidebar - Chat List -->
                <div class="w-full lg:w-80 bg-white border-r border-gray-200 flex flex-col">
                    <!-- Search Bar -->
                    <div
                        class="p-4 border-b border-gray-200 lg:block search_input_box @if ($spec_manufacturer != '') hidden @endif">
                        <input type="text" placeholder="Search chats..."
                            class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            onkeyup="searchChat(this)">
                    </div>

                    <!-- Chat List -->
                    <div
                        class="lg:flex-1 lg:block overflow-y-auto chat_list  @if ($spec_manufacturer != '') hidden @endif">
                        @php
                            // Get all unique user IDs that have chat history with the current user
                            $chatPartners = \App\Models\Chat::where(function ($query) use ($user_uid) {
                                $query->where('sent_by', $user_uid)->orWhere('sent_to', $user_uid);
                            })
                                ->get()
                                ->map(function ($chat) use ($user_uid) {
                                    // Return the other user's ID (the chat partner)
                                    return $chat->sent_by === $user_uid ? $chat->sent_to : $chat->sent_by;
                                })
                                ->unique()
                                ->values();

                            // Filter users to only those with chat history
                            $usersWithChats = $chat_with->filter(function ($user) use ($chatPartners, $user_uid_type) {
                                return $chatPartners->contains($user->{$user_uid_type});
                            });
                        @endphp

                        @forelse ($usersWithChats as $user)
                            @php
                                $userId = $user->{$user_uid_type};

                                // Get unseen message count (messages sent TO current user that are unseen)
                                $unseenCount = \App\Models\Chat::where('sent_to', $user_uid)
                                    ->where('sent_by', $userId)
                                    ->where('seen', 0)
                                    ->count();

                                // Get last message
                                $lastMessage = \App\Models\Chat::where(function ($query) use ($user_uid, $userId) {
                                    $query
                                        ->where(function ($q) use ($user_uid, $userId) {
                                            $q->where('sent_by', $user_uid)->where('sent_to', $userId);
                                        })
                                        ->orWhere(function ($q) use ($user_uid, $userId) {
                                            $q->where('sent_by', $userId)->where('sent_to', $user_uid);
                                        });
                                })
                                    ->latest()
                                    ->first();

                                // Format last message time
                                $lastMessageTime = $lastMessage
                                    ? $lastMessage->created_at->diffForHumans(null, true, true)
                                    : '';

                                // Format last message text based on message type
                                if ($lastMessage) {
                                    if ($lastMessage->message_type === 'text') {
                                        $lastMessageText = \Illuminate\Support\Str::limit(
                                            $lastMessage->main_message,
                                            40,
                                        );
                                        $messageIcon = '';
                                    } else {
                                        // Determine if it was sent or received
                                        $isSent = $lastMessage->sent_by === $user_uid;

                                        // Get appropriate icon and text based on message type
                                        switch ($lastMessage->message_type) {
                                            case 'image':
                                                $messageIcon = '<i class="fas fa-image"></i>';
                                                $lastMessageText = $isSent ? 'Photo sent' : 'Photo received';
                                                break;
                                            case 'file':
                                            case 'document':
                                                $messageIcon = '<i class="fas fa-file-alt"></i>';
                                                $lastMessageText = $isSent ? 'File sent' : 'File received';
                                                break;
                                            case 'video':
                                                $messageIcon = '<i class="fas fa-video"></i>';
                                                $lastMessageText = $isSent ? 'Video sent' : 'Video received';
                                                break;
                                            case 'audio':
                                                $messageIcon = '<i class="fas fa-microphone"></i>';
                                                $lastMessageText = $isSent ? 'Audio sent' : 'Audio received';
                                                break;
                                            default:
                                                $messageIcon = '<i class="fas fa-paperclip"></i>';
                                                $lastMessageText = $isSent ? 'File sent' : 'File received';
                                        }
                                    }
                                } else {
                                    $lastMessageText = 'No messages yet';
                                    $messageIcon = '';
                                }

                                // Determine profile picture
                                if ($sending_to_type === 'manufacturer') {
                                    // Current user is wholesaler, showing manufacturers
                                    $profilePicture = $user->company_logo
                                        ? asset($user->company_logo)
                                        : 'https://ui-avatars.com/api/?name=' .
                                            urlencode($user->name ?? ($user->company_name_en ?? 'User')) .
                                            '&background=3b82f6&color=fff';
                                    $userName = $user->company_name_en;
                                } else {
                                    // Current user is manufacturer, showing wholesalers
                                    $profilePicture = $user->profile_picture
                                        ? asset($user->profile_picture)
                                        : 'https://ui-avatars.com/api/?name=' .
                                            urlencode($user->company_name ?? 'User') .
                                            '&background=3b82f6&color=fff';
                                    $userName = $user->company_name ?? 'User';
                                }
                            @endphp

                            <div class="chat_tab inactive_chat_tab" data-userid="{{ $userId }}"
                                onclick="activateChat(this)">
                                <img src="{{ $profilePicture }}" alt="{{ $userName }}"
                                    class="w-12 h-12 rounded-full chat_user_img object-cover"
                                    onerror="this.src='https://ui-avatars.com/api/?name={{ urlencode($userName) }}&background=3b82f6&color=fff'">
                                <div class="flex-1 min-w-0">
                                    <div class="flex justify-between items-baseline">
                                        <h3 class="font-semibold text-gray-900 truncate chat_user_name">
                                            {{ $userName }}
                                        </h3>
                                        @if ($lastMessageTime)
                                            <span class="text-xs text-gray-500">{{ $lastMessageTime }}</span>
                                        @endif
                                    </div>
                                    <p class="text-sm text-gray-600 truncate">
                                        @if ($messageIcon)
                                            {!! $messageIcon !!}
                                        @endif
                                        {{ $lastMessageText }}
                                    </p>
                                </div>
                                @if ($unseenCount > 0)
                                    <span class="unread_badge">{{ $unseenCount }}</span>
                                @else
                                    <span class="unread_badge hidden">0</span>
                                @endif
                            </div>
                        @empty
                            <div class="p-4 text-center text-gray-500">
                                <p>No chat history yet</p>
                            </div>
                        @endforelse
                    </div>
                </div>

                {{-- Messaging Arena --}}
                <div
                    class="@if ($spec_manufacturer == '') hidden @endif lg:flex-1 lg:flex lg:flex-col bg-gray-50 relative overflow-y-auto chat_area">
                    @if ($spec_manufacturer == '')
                        <div class="bg-white border-b border-gray-200 px-6 py-4 flex items-center gap-4">
                            <svg class="w-12 h-12 text-gray-600 cursor-pointer absolute left-[-0.5rem] pr-2 back_arrow"
                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round" onclick="showChatList(this)">
                                <path d="M15 18l-6-6 6-6" />
                            </svg>
                            <img src="https://ui-avatars.com/api/?name=Select+User&background=3b82f6&color=fff"
                                alt="Select User" class="w-10 h-10 rounded-full activated_user_img">
                            <div class="flex-1">
                                <h2 class="font-semibold text-gray-900 activated_user_name">Select a chat</h2>
                                <p class="text-sm text-gray-500 activity">Select a user to start chatting</p>
                            </div>
                        </div>
                    @else
                        <div class="bg-white border-b border-gray-200 px-6 py-4 flex items-center gap-4">
                            <svg class="w-12 h-12 text-gray-600 cursor-pointer absolute left-[-0.5rem] pr-2 back_arrow"
                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round" onclick="showChatList(this)">
                                <path d="M15 18l-6-6 6-6" />
                            </svg>
                            <img src="{{ $spec_manufacturer->company_logo ? asset($spec_manufacturer->company_logo) : 'https://ui-avatars.com/api/?name=' . urlencode($spec_manufacturer->company_name_en) . '&background=3b82f6&color=fff' }}"
                                alt="Select User" class="w-10 h-10 rounded-full activated_user_img">
                            <div class="flex-1">
                                <h2 class="font-semibold text-gray-900 activated_user_name">
                                    {{ $spec_manufacturer->company_name_en }}</h2>
                                <p class="text-sm text-gray-500 activity capitalize">{{ $online_status }} Now</p>
                            </div>
                        </div>
                    @endif

                    <!-- Messages Area -->
                    <div class="flex-1 overflow-y-auto px-6 py-4 space-y-2" id="messagesContainer">
                        <div class="empty_chat_area text-center py-8">
                            <svg class="w-32 h-32 mb-4 mx-auto" fill="none" stroke="currentColor"
                                viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
                                    d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                            </svg>
                            <p class="text-lg font-medium">No chat selected</p>
                            <p class="text-sm">Select a user from the left to view messages</p>
                        </div>
                    </div>

                    <!-- Message Box To Send Message -->
                    <div class="bg-white border-t border-gray-200 message-input-container">
                        <div id="filePreview" class="mt-3 hidden px-2 lg:px-6">
                            <div class="flex items-center gap-3 bg-blue-50 p-3 rounded-lg">
                                <div id="filePreviewContent" class="max-w-[calc(100%-2rem)] overflow-hidden"></div>
                                <button onclick="cancelFileUpload()"
                                    class="text-red-500 hover:text-red-700 flex-shrink-0">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="flex items-end gap-1 lg:gap-3 w-full lg:px-4 lg:py-2">
                            <input type="hidden" name="_token" class="csrf_token" value="{{ csrf_token() }}">
                            <input type="hidden" name="sending_to" class="sending_to" value="">

                            <!-- Attachment Options -->
                            <div class="relative flex-shrink-0">
                                <button
                                    class="text-gray-500 hover:text-gray-700 p-2 rounded-lg hover:bg-gray-100 attachment-btn">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
                                    </svg>
                                </button>
                                <input type="file" id="fileInput" class="hidden"
                                    accept=".jpg,.jpeg,.png,.gif,.pdf,.doc,.docx,.ppt,.pptx">
                            </div>

                            <!-- Message Input -->
                            <div
                                class="flex-1 bg-gray-100 rounded-2xl px-4 py-2 flex items-center message-input-wrapper min-w-0">
                                <textarea placeholder="Type a message..."
                                    class="flex-1 bg-transparent border-none focus:outline-none text-gray-900 placeholder-gray-500 message_box resize-none min-h-[40px] max-h-[120px] w-full"
                                    rows="1"></textarea>
                            </div>

                            <!-- Send Button -->
                            <button
                                class="bg-blue-400 hover:bg-blue-500 text-white p-3 rounded-full transition-colors send-btn flex-shrink-0"
                                onclick="sendMessage(this)">
                                <svg class="w-5 h-5 transform rotate-90" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 19l9 2-9-18-9 18l9-2zm0 0v-8" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Preview Images -->
        <div id="fileModal" class="fixed inset-0 flex items-center justify-center hidden z-50"
            onclick="closeFileModal()">
            <div class="bg-white rounded-lg max-w-4xl max-h-4/5 overflow-auto">
                <div class="flex justify-between items-center relative">
                    <button onclick="closeFileModal()"
                        class="text-gray-500 hover:text-gray-700 absolute top-0 right-0 p-1 bg-white rounded-full">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="min-h-[300px] min-w-[300px] bg-[#00000080]" id="modalContent"></div>
            </div>
        </div>
    </div>


    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.all.min.js"></script>
    <script src="/assets/js/messaging.js"></script>


    <script>
        @if (Session::has('success'))
            Swal.fire({
                icon: 'success',
                title: 'Success!',
                text: "{{ Session::get('success') }}",
                timer: 3000,
                showConfirmButton: false
            });
        @endif

        @if (Session::has('error'))
            Swal.fire({
                icon: 'error',
                title: 'Error!',
                text: "{{ Session::get('error') }}",
                timer: 4000,
                showConfirmButton: true
            });
        @endif

        @if (Session::has('info'))
            Swal.fire({
                icon: 'info',
                title: 'Information',
                text: "{{ Session::get('info') }}",
                timer: 3000,
                showConfirmButton: false
            });
        @endif

        @if (Session::has('warning'))
            Swal.fire({
                icon: 'warning',
                title: 'Warning!',
                text: "{{ Session::get('warning') }}",
                timer: 4000,
                showConfirmButton: true
            });
        @endif

        var user_uid = "{{ $user_uid }}";
        var spec_manufacturer_uid = "{{ $spec_manufacturer ? $spec_manufacturer->manufacturer_uid : '' }}";

        function searchChat(input) {
            let searchTerm = $(input).val().toLowerCase().trim();

            if (searchTerm === '' || searchTerm === null) {
                $('.chat_tab').removeClass('hidden');
            } else {
                $('.chat_tab').addClass('hidden');
                $('.chat_tab').each(function() {
                    let userName = $(this).find('.chat_user_name').text().toLowerCase();
                    if (userName.includes(searchTerm)) {
                        $(this).removeClass('hidden');
                    }
                });
            }
        }

        $(document).ready(function() {
            if (spec_manufacturer_uid) {
                let chatTab = $(`.chat_tab[data-userid="${spec_manufacturer_uid}"]`);
                if (chatTab.length > 0) {
                    activateChat(chatTab[0]);
                } else {
                    sending_to = spec_manufacturer_uid;
                    $(".sending_to").val(spec_manufacturer_uid);
                    @if ($spec_manufacturer)
                        $(".activated_user_img").attr('src',
                            "{{ $spec_manufacturer->company_logo ? asset($spec_manufacturer->company_logo) : 'https://ui-avatars.com/api/?name=' . urlencode($spec_manufacturer->company_name_en) . '&background=3b82f6&color=fff' }}"
                        );
                        $(".activated_user_name").html("{{ $spec_manufacturer->company_name_en }}");
                        $(".activity").html('Active now');
                    @endif
                    $("#messagesContainer").html(emptyChat);
                }
            }
        });
    </script>


    <script src="{{ asset('assets/js/chat-websocket.js') }}"></script>
</body>

</html>



messaging.js:
var csrf_token = $(".csrf_token").val();
var sending_to = $(".sending_to").val();
var currentFile = null;
var previousChatUserId = null; // Track previously opened chat

$(document).ready(function () {
    $('#fileInput').on('change', function (e) {
        handleFileSelect(e);
    });

    $('.attachment-btn').on('click', function () {
        $('#fileInput').click();
    });

    $('.message_box').on('keypress', function (e) {
        if (e.which === 13) {
            e.preventDefault();
            sendMessage($('.send-btn'));
        }
    });

    $('.message_box').on('input', function () {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });
});

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'application/pdf',
        'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'];

    if (!allowedTypes.includes(file.type)) {
        toastr.error('Only images, PDF, DOC, and PPT files are allowed.');
        return;
    }

    if (file.size > 20 * 1024 * 1024) {
        toastr.error('File size must be less than 20MB.');
        return;
    }

    currentFile = file;
    showFilePreview(file);
}

function showFilePreview(file) {
    const preview = $('#filePreview');
    const previewContent = $('#filePreviewContent');

    if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = function (e) {
            previewContent.html(`
                <img src="${e.target.result}" class="w-16 h-16 object-cover rounded" alt="Preview">
                <span class="text-sm">${file.name}</span>
            `);
        };
        reader.readAsDataURL(file);
    } else {
        const icon = getFileIcon(file.type);
        previewContent.html(`
            <div class="flex items-center gap-3">
                ${icon}
                <span class="text-sm">${file.name}</span>
            </div>
        `);
    }

    preview.removeClass('hidden');
}

function cancelFileUpload() {
    currentFile = null;
    $('#fileInput').val('');
    $('#filePreview').addClass('hidden');
    $('#filePreviewContent').html('');
}

function uploadFile(messageText = '') {
    if (!currentFile || !sending_to) return;

    const formData = new FormData();
    formData.append('file', currentFile);
    formData.append('sending_to', sending_to);
    formData.append('message_text', messageText);
    formData.append('_token', csrf_token);

    const tempMessageId = 'temp_' + Date.now();
    displayFileMessageWithLoader(currentFile, true, messageText, tempMessageId);

    updateChatListOnSend({
        messageType: 'file',
        message: messageText || 'File sent',
        timestamp: new Date().toISOString()
    });

    $.ajax({
        url: '/send-file-message',
        type: 'POST',
        data: formData,
        processData: false,
        contentType: false,
        success: function (response) {
            if (response.status === 'success') {
                $(`#${tempMessageId}`).remove();
                displayFileMessage(response.file_data, true, response.message_text, response.message_uid, false);

                if (window.ws && window.ws.readyState === WebSocket.OPEN) {
                    window.ws.send(JSON.stringify({
                        type: 'update_chat_list',
                        fromUserId: sending_to,
                        timestamp: new Date().toISOString()
                    }));
                }

                cancelFileUpload();
                scrollToBottom();
            }
        },
        error: function (xhr, status, error) {
            console.error('Error uploading file:', error);
            $(`#${tempMessageId}`).remove();
            toastr.error('Error uploading file. Please try again.');
        }
    });
}

function displayFileMessageWithLoader(file, isSent, messageText, tempId) {
    const messageClass = isSent ? 'sent_message' : 'received_message';
    const alignClass = isSent ? 'items-end' : 'items-start';
    const bgClass = isSent ? 'bg-blue-400' : 'bg-purple-400';

    const loaderHtml = `
        <div class="${messageClass}" id="${tempId}">
            <div class="flex flex-col gap-0 ${alignClass}">
                <div class="file-message min-w-[50px] max-w-[200px] lg:min-w-[120px] lg:max-w-[300px]">
                    <div class="flex items-center gap-3 p-3 ${bgClass} text-white rounded-2xl">
                        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-white"></div>
                        <span class="text-sm">Uploading...</span>
                    </div>
                </div>
            </div>
        </div>`;

    $("#messagesContainer").append(loaderHtml);
    $(".empty_chat_area").remove();
    scrollToBottom();
}

function updateChatListOnSend(messageData) {
    const sendingToType = $('meta[name="user-type"]').attr('content') === 'wholesaler' ? 'manufacturer' : 'wholesaler';
    let chatTab = $(`.chat_tab[data-userid="${sending_to}"]`);
    if (chatTab.length > 0) {
        updateSentChatTab(chatTab, messageData);
        chatTab.prependTo('.chat_list');
    } else {
        createNewChatTabOnSend(sending_to, sendingToType, messageData);
    }
}

function updateSentChatTab(chatTab, messageData) {
    let lastMessageText = '';
    let messageIcon = '';
    if (messageData.messageType === 'text') {
        lastMessageText = messageData.message.length > 40 ?
            messageData.message.substring(0, 40) + '...' :
            messageData.message;
    } else if (messageData.messageType === 'file') {
        messageIcon = '<i class="fas fa-file-alt"></i>';
        lastMessageText = 'File sent';
    }
    const lastMessageHtml = messageIcon ?
        `${messageIcon} ${lastMessageText}` :
        lastMessageText;
    chatTab.find('.text-sm').html(lastMessageHtml);
    chatTab.find('.text-xs.text-gray-500').text('Just now');
    
    chatTab.find('.unread_badge').addClass('hidden').text('0');
}

function createNewChatTabOnSend(userId, sendingToType, messageData) {
    $.ajax({
        url: '/get-chat-list-item',
        type: 'POST',
        data: {
            'user_id': userId,
            'sending_to_type': sendingToType,
            'current_user_id': user_uid,
            '_token': csrf_token
        },
        success: function (response) {
            if (response.status === 'success') {
                const user = response.user;
                let lastMessageText = '';
                let messageIcon = '';

                if (messageData.messageType === 'text') {
                    lastMessageText = messageData.message.length > 40 ?
                        messageData.message.substring(0, 40) + '...' :
                        messageData.message;
                } else if (messageData.messageType === 'file') {
                    messageIcon = '<i class="fas fa-file-alt"></i>';
                    lastMessageText = 'File sent';
                }

                const chatTabHtml = `
                    <div class="chat_tab inactive_chat_tab" data-userid="${user.id}" onclick="activateChat(this)">
                        <img src="${user.profile_picture}" alt="${user.name}"
                            class="w-12 h-12 rounded-full chat_user_img object-cover"
                            onerror="this.src='https://ui-avatars.com/api/?name=${encodeURIComponent(user.name)}&background=3b82f6&color=fff'">
                        <div class="flex-1 min-w-0">
                            <div class="flex justify-between items-baseline">
                                <h3 class="font-semibold text-gray-900 truncate chat_user_name">
                                    ${user.name}
                                </h3>
                                <span class="text-xs text-gray-500">Just now</span>
                            </div>
                            <p class="text-sm text-gray-600 truncate">
                                ${messageIcon} ${lastMessageText}
                            </p>
                        </div>
                        <span class="unread_badge hidden">0</span>
                    </div>
                `;

                $('.chat_list').prepend(chatTabHtml);
            }
        },
        error: function (xhr, status, error) {
            console.error('Error fetching chat list item:', error);
        }
    });
}

function sendMessage(passedThis) {
    let message_box = ($(".message_box").val()).trim();

    if (currentFile) {
        uploadFile(message_box);
        $(".message_box").val('');
        resetTextareaHeight();
        return;
    }

    if (message_box !== '' && message_box !== null && sending_to) {
        const tempMessageUid = 'temp_' + Date.now();
        displayTextMessage(message_box, true, tempMessageUid, false);
        $(".message_box").val('');
        resetTextareaHeight();
        scrollToBottom();
        updateChatListOnSend({
            messageType: 'text',
            message: message_box,
            timestamp: new Date().toISOString()
        });

        if (window.sendStopTypingIndicator) {
            window.sendStopTypingIndicator();
        }

        $.ajax({
            url: '/send-text-message',
            type: 'POST',
            data: {
                'sending_to': sending_to,
                'message_box': message_box,
                '_token': csrf_token
            },
            success: function (response) {
                $(`[data-message-uid="${tempMessageUid}"]`).attr('data-message-uid', response.message_uid);
                console.log('Message saved to database');
                if (window.ws && window.ws.readyState === WebSocket.OPEN) {
                    window.ws.send(JSON.stringify({
                        type: 'update_chat_list',
                        fromUserId: sending_to,
                        timestamp: new Date().toISOString()
                    }));
                }
            },
            error: function (xhr, status, error) {
                console.error('Error sending message:', error);
                toastr.error('Failed to send message. Please try again.');
            }
        });
    }
}

function resetTextareaHeight() {
    const messageBox = $('.message_box');
    messageBox.css('height', 'auto');
    messageBox.css('height', '40px');
}

function scrollToBottom() {
    const messagesContainer = document.getElementById('messagesContainer');
    if (messagesContainer) {
        requestAnimationFrame(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        });
    }
}

$('.message_box').on('input', function () {
    this.style.height = 'auto';
    const newHeight = Math.min(this.scrollHeight, 120);
    this.style.height = newHeight + 'px';
});

function displayTextMessage(message, isSent, messageUid = null, seenStatus = false) {
    const now = new Date();
    const d = new Date();
    const dateTimeString = `${d.getDate().toString().padStart(2, '0')}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getFullYear().toString().slice(-2)}, ${d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })}`;

    const messageClass = isSent ? 'sent_message' : 'received_message';
    const alignClass = isSent ? 'items-end' : 'items-start';
    const bgClass = isSent ? 'bg-blue-500 text-white rounded-2xl rounded-tr-none' : 'bg-[#843ffe] text-white rounded-2xl rounded-tl-none';

    const seenIndicator = isSent ? `
        <i class="fas fa-check-double ${seenStatus ? 'text-blue-400' : 'text-gray-400'} text-xs ml-1" title="${seenStatus ? 'Seen' : 'Sent'}"></i>
    ` : '';

    const new_message = `
        <div class="${messageClass}" data-message-uid="${messageUid || ''}">
            <div class="flex flex-col gap-1 ${alignClass} cursor-pointer" onclick="toggleTime(this)">
                <div class="${bgClass} px-4 py-2 max-w-md break-words">
                    <p style="white-space: pre-wrap;" class="text-xs lg:text-sm">${escapeHtml(message)}</p>
                </div>
                <span class="text-xs text-gray-500 ${isSent ? 'mr-2' : 'ml-2'} hidden time flex items-center gap-1">
                    ${dateTimeString}
                    ${seenIndicator}
                </span>
            </div>
        </div>`;

    $("#messagesContainer").append(new_message);
    $(".empty_chat_area").remove();
}

function displayFileMessage(fileData, isSent, messageText = '', messageUid = null, seenStatus = false) {
    const now = new Date();
    const d = new Date();
    const dateTimeString = `${d.getDate().toString().padStart(2, '0')}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getFullYear().toString().slice(-2)}, ${d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })}`;

    const messageClass = isSent ? 'sent_message' : 'received_message';
    const alignClass = isSent ? 'items-end' : 'items-start';
    const bgClass = isSent ? 'bg-blue-500 text-white' : 'bg-[#843ffe] text-white';

    const seenIndicator = isSent ? `
        <i class="fas fa-check-double ${seenStatus ? 'text-blue-400' : 'text-gray-400'} text-xs ml-1" title="${seenStatus ? 'Seen' : 'Sent'}"></i>
    ` : '';

    let fileContent = '';
    if (fileData.file_type.startsWith('image/')) {
        const imageRoundClass = messageText
            ? 'rounded-t-2xl'
            : (isSent ? 'rounded-2xl rounded-tr-none' : 'rounded-2xl rounded-tl-none');

        fileContent = `
            <img src="${fileData.file_url}" alt="Shared image" 
                 class="w-full h-auto ${imageRoundClass} cursor-pointer file-preview"
                 onclick="openFileModal('${fileData.file_url}', 'image')">
        `;
    } else {
        const fileRoundClass = messageText
            ? 'rounded-t-2xl'
            : (isSent ? 'rounded-2xl rounded-tr-none' : 'rounded-2xl rounded-tl-none');

        const icon = getFileIcon(fileData.file_type);
        fileContent = `
            <div class="flex items-center gap-0 p-3 ${bgClass} ${fileRoundClass}">
                <div class="flex-shrink-0">
                    ${icon}
                </div>
                <div class="flex-1 min-w-0">
                    <p class="text-sm font-medium truncate">${fileData.original_name}</p>
                    <a href="${fileData.file_url}" target="_blank" 
                       class="text-xs underline hover:no-underline inline-block mt-1">
                        Open file
                    </a>
                </div>
            </div>
        `;
    }

    const textContent = messageText ? `
        <div class="${bgClass} px-4 py-2 ${isSent ? 'rounded-b-2xl rounded-tr-none' : 'rounded-b-2xl rounded-tl-none'} max-w-xs break-words">
            <p style="white-space: pre-wrap;" class="text-xs lg:text-sm">${escapeHtml(messageText)}</p>
        </div>
    ` : '';

    const new_message = `
        <div class="${messageClass}" data-message-uid="${messageUid || ''}">
            <div class="flex flex-col gap-0 ${alignClass} cursor-pointer" onclick="toggleTime(this)">
                <div class="file-message min-w-[50px] max-w-[200px] lg:min-w-[120px] lg:max-w-[300px]">
                    ${fileContent}
                    ${textContent}
                </div>
                <span class="text-xs text-gray-500 ${isSent ? 'mr-2' : 'ml-2'} hidden time flex items-center gap-1">
                    ${dateTimeString}
                    ${seenIndicator}
                </span>
            </div>
        </div>`;

    $("#messagesContainer").append(new_message);
    $(".empty_chat_area").remove();
}

function getFileIcon(fileType) {
    if (fileType.includes('pdf')) {
        return `<svg class="w-10 h-10 text-red-400" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18.5,9H13V3.5L18.5,9M6,20V4H12V10H18V20H6Z"/>
                </svg>`;
    }

    if (fileType.includes('word') || fileType.includes('document')) {
        return `<svg class="w-10 h-10 text-blue-400" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M7,11H9L10,16L11,11H13L14,16L15,11H17L15,19H13L12,14L11,19H9L7,11Z"/>
                </svg>`;
    }

    if (fileType.includes('powerpoint') || fileType.includes('presentation')) {
        return `<svg class="w-10 h-10 text-orange-400" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M10,11V13H13V11H10M10,14V16H11V15H12V16H13V14H10Z"/>
                </svg>`;
    }

    return `<svg class="w-10 h-10 text-gray-400" fill="currentColor" viewBox="0 0 24 24">
                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M10,19L12,15H9V10H15V15L13,19H10Z"/>
            </svg>`;
}

function openFileModal(url, type) {
    const modal = $('#fileModal');
    const modalContent = $('#modalContent');

    if (type === 'image') {
        modalContent.html(`<img src="${url}" class="w-full h-auto" alt="Preview">`);
    }

    modal.removeClass('hidden');
}

function closeFileModal() {
    $('#fileModal').addClass('hidden');
}

function toggleTime(passedThis) {
    let timeElement = $(passedThis).find('.time');
    timeElement.toggleClass('hidden');
}

function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}

function showChatList() {
    // CRITICAL: Notify server that we're closing the current chat
    if (sending_to && window.notifyChatClosed) {
        window.notifyChatClosed(sending_to);
    }
    
    $(".chat_area").addClass('hidden');
    $(".chat_list").removeClass("hidden");
    $(".search_input_box").removeClass("hidden");
    $(".chat_header").removeClass("hidden");
    
    // Clear the sending_to to indicate no chat is open
    sending_to = "";
    $(".sending_to").val("");
}

var emptyChat = `<div class="empty_chat_area text-center py-8">
                    <svg class="w-32 h-32 mb-4 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
                            d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                    <p class="text-lg font-medium">No messages yet</p>
                    <p class="text-sm">Start a conversation by sending a message</p>
                </div>`;

function activateChat(passedThis) {
    // CRITICAL: Close previous chat if exists
    if (previousChatUserId && window.notifyChatClosed) {
        window.notifyChatClosed(previousChatUserId);
        console.log('ðŸ”’ Closed previous chat with:', previousChatUserId);
    }
    
    $('.chat_tab').removeClass('active_chat_tab');
    $(passedThis).addClass('active_chat_tab');
    
    let activated_user_img = $(passedThis).find('.chat_user_img').attr('src');
    let activated_user_name = $(passedThis).find('.chat_user_name').html();
    sending_to = $(passedThis).attr("data-userid");
    
    $(".chat_area").removeClass('hidden');
    $(".chat_list").addClass("hidden");
    $(".search_input_box").addClass("hidden");
    $(".chat_header").addClass("hidden");

    $(".activated_user_img").attr('src', activated_user_img);
    $(".activated_user_name").html(activated_user_name);
    $(".activity").html('Active now');
    $(".sending_to").val(sending_to);
    $("#messagesContainer").html('');

    // Reset unread badge for this chat
    $(passedThis).find(".unread_badge").addClass('hidden').text('0');

    // CRITICAL: Notify server that chat is opened with this user
    if (window.notifyChatOpened) {
        window.notifyChatOpened(sending_to);
        console.log('ðŸ”“ Opened chat with:', sending_to);
    }
    
    // Update previous chat user ID
    previousChatUserId = sending_to;
    
    if (window.requestOnlineStatus) {
        window.requestOnlineStatus(sending_to);
    }

    // Fetch and display messages
    $.ajax({
        url: '/fetch-chats',
        type: 'POST',
        data: {
            'sending_to': sending_to,
            '_token': csrf_token
        },
        success: function (response) {
            $("#messagesContainer").html('');
            $("#messagesContainer").addClass('opacity-0');

            if (response.messages.length == 0) {
                $("#messagesContainer").html(emptyChat);
                return;
            } else {
                response.messages.forEach(message => {
                    const isSent = message.sent_by == user_uid;
                    const seenStatus = message.seen == 1;

                    if (message.message_type == 'text') {
                        displayTextMessage(message.main_message, isSent, message.message_uid, seenStatus);
                    } else if (message.message_type == 'file') {
                        const messageData = JSON.parse(message.main_message);
                        displayFileMessage(messageData.file_data, isSent, messageData.message_text || '', message.message_uid, seenStatus);
                    }
                });
            }

            setTimeout(() => {
                scrollToBottom();
                $("#messagesContainer").removeClass('opacity-0');

                // CRITICAL: Mark ALL unseen messages as seen when opening chat
                const allUnseenMessages = response.messages.filter(msg =>
                    msg.sent_by === sending_to && msg.seen === 0
                );

                if (allUnseenMessages.length > 0) {
                    const allUnseenUids = allUnseenMessages.map(msg => msg.message_uid);
                    console.log('ðŸ”µ Marking ALL unseen messages as seen on chat open:', allUnseenUids);
                    markMessagesAsSeenInBackend(allUnseenUids, sending_to);

                    // Update UI immediately
                    allUnseenUids.forEach(uid => {
                        const messageElement = $(`[data-message-uid="${uid}"]`);
                        if (messageElement.length > 0) {
                            const seenIndicator = messageElement.find('.time i.fa-check-double');
                            if (seenIndicator.length > 0) {
                                seenIndicator.removeClass('text-gray-400').addClass('text-blue-400');
                                seenIndicator.attr('title', 'Seen');
                            }
                        }
                    });
                }

                setTimeout(() => {
                    scrollToBottom();
                }, 200);
            }, 10);
        },
        error: function (xhr, status, error) {
            console.error('Error fetching messages:', error);
        }
    });
}

// Helper function to mark messages as seen in backend
function markMessagesAsSeenInBackend(messageUids, senderId) {
    if (!messageUids || messageUids.length === 0) return;
    
    $.ajax({
        url: '/mark-messages-seen',
        type: 'POST',
        data: {
            'message_uids': messageUids,
            'sender_id': senderId,
            '_token': csrf_token
        },
        success: function (response) {
            console.log('âœ… Messages marked as seen in database');
        },
        error: function (xhr, status, error) {
            console.error('âŒ Error marking messages as seen:', error);
        }
    });
}



chat-websocket.js:
// WebSocket connection for chat page
let ws = null;
let reconnectInterval = null;
let typingTimeout = null;
let isTyping = false;

// Initialize WebSocket connection
function initWebSocket() {
    const userType = $('meta[name="user-type"]').attr('content');
    const wsUrl = `ws://localhost:3000?userId=${user_uid}&userType=${userType}`;

    // Use global WebSocket if available, otherwise create new one
    if (window.globalWebSocket && window.globalWebSocket.ws) {
        ws = window.globalWebSocket.ws;
        console.log('âœ… Using existing global WebSocket connection');
        setupWebSocketHandlers();
        return;
    }

    ws = new WebSocket(wsUrl);

    ws.onopen = function () {
        console.log('ðŸ’¬ Chat WebSocket connected');
        clearInterval(reconnectInterval);

        // Notify server about currently open chat if any
        if (sending_to) {
            notifyChatOpened(sending_to);
            requestOnlineStatus(sending_to);
        }

        showConnectionStatus('connected');
    };

    ws.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);
            handleWebSocketMessage(data);
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    };

    ws.onerror = function (error) {
        console.error('ðŸ’¬ Chat WebSocket error:', error);
        showConnectionStatus('error');
    };

    ws.onclose = function () {
        console.log('ðŸ’¬ Chat WebSocket disconnected');
        showConnectionStatus('disconnected');

        reconnectInterval = setInterval(function () {
            console.log('Attempting to reconnect...');
            initWebSocket();
        }, 5000);
    };
}

function setupWebSocketHandlers() {
    if (!ws) return;

    // Override the global message handler for chat-specific messages
    const originalOnMessage = ws.onmessage;
    ws.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);

            // Handle chat-specific messages
            if (data.type === 'user_typing' ||
                data.type === 'messages_seen' ||
                data.type === 'online_status' ||
                data.type === 'user_status_changed' ||
                data.type === 'update_chat_list') {
                handleWebSocketMessage(data);
            }

            // Also call original handler if it exists
            if (originalOnMessage) {
                originalOnMessage.call(this, event);
            }
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    };
}

// Handle incoming WebSocket messages
function handleWebSocketMessage(data) {
    console.log('ðŸ’¬ Chat WebSocket message:', data.type);

    switch (data.type) {
        case 'connected':
            console.log('Connected to chat server:', data.message);
            break;

        case 'new_message':
            handleNewMessage(data);
            break;

        case 'user_typing':
            handleUserTyping(data);
            break;

        case 'messages_seen':
            handleMessagesSeen(data);
            break;

        case 'online_status':
            handleOnlineStatus(data);
            break;

        case 'user_status_changed':
            handleUserStatusChanged(data);
            break;

        case 'update_chat_list':
            handleChatListUpdate(data);
            break;

        case 'pong':
            // Heartbeat response
            break;

        default:
            console.log('Unknown message type:', data.type);
    }
}

// Handle new incoming message (sent from server after DB save)
function handleNewMessage(data) {
    console.log('New message received:', data);

    // Check if the message is from the currently active chat
    const isFromActiveChat = data.senderId === sending_to;
    console.log('Is from active chat:', isFromActiveChat, 'senderId:', data.senderId, 'sending_to:', sending_to);

    if (isFromActiveChat) {
        // Message is from the currently active chat - display it
        console.log('Message from active chat');
        const isSeen = data.seen || false;

        if (data.messageType === 'text') {
            displayTextMessage(data.message, false, data.messageUid, isSeen);
        } else if (data.messageType === 'file') {
            displayFileMessage(data.fileData, false, data.messageText, data.messageUid, isSeen);
        }

        scrollToBottom();

        // CRITICAL: Since we have the chat open with this sender, mark as seen
        if (!isSeen) {
            console.log('ðŸ”µ Marking incoming message as seen (chat is open):', data.messageUid);
            markMessagesAsSeenInBackend([data.messageUid], data.senderId);
        }

        // Update chat list WITHOUT incrementing unread badge for active chat
        updateChatListItem(data.senderId, data, false);
    } else {
        // Message is from another chat - update unread badge or create new chat tab
        console.log('Message from different chat, updating unread badge');
        
        // Check if chat tab exists for this user
        const chatTab = $(`.chat_tab[data-userid="${data.senderId}"]`);
        
        if (chatTab.length > 0) {
            // Update existing chat tab WITH unread badge increment
            updateChatListItem(data.senderId, data, true);
        } else {
            // Create new chat tab for this user with unread badge
            createNewChatTabFromMessage(data.senderId, data);
        }

        // Play notification sound for messages from other chats
        playNotificationSound();
    }
}

// Create new chat tab when message arrives from new user
function createNewChatTabFromMessage(userId, messageData) {
    const sendingToType = $('meta[name="user-type"]').attr('content') === 'wholesaler' ? 'manufacturer' : 'wholesaler';
    
    // Check if this is from the currently active chat
    const isFromActiveChat = userId === sending_to;
    
    console.log('createNewChatTabFromMessage - userId:', userId, 'sending_to:', sending_to, 'isFromActiveChat:', isFromActiveChat);

    $.ajax({
        url: '/get-chat-list-item',
        type: 'POST',
        data: {
            'user_id': userId,
            'sending_to_type': sendingToType,
            'current_user_id': user_uid,
            '_token': csrf_token
        },
        success: function (response) {
            if (response.status === 'success') {
                const user = response.user;
                
                const isSent = messageData.senderId === user_uid;
                let lastMessageText = '';
                let messageIcon = '';

                if (messageData.messageType === 'text') {
                    lastMessageText = messageData.message.length > 40 ?
                        messageData.message.substring(0, 40) + '...' :
                        messageData.message;
                } else if (messageData.messageType === 'file') {
                    messageIcon = '<i class="fas fa-file-alt"></i>';
                    lastMessageText = isSent ? 'File sent' : 'File received';
                }

                // Only show unread badge if NOT from active chat AND message is from other user
                const unreadCount = (!isFromActiveChat && !isSent) ? 1 : 0;

                console.log('Creating new chat tab from message with unreadCount:', unreadCount);

                const chatTabHtml = `
                    <div class="chat_tab inactive_chat_tab" data-userid="${user.id}" onclick="activateChat(this)">
                        <img src="${user.profile_picture}" alt="${user.name}"
                            class="w-12 h-12 rounded-full chat_user_img object-cover"
                            onerror="this.src='https://ui-avatars.com/api/?name=${encodeURIComponent(user.name)}&background=3b82f6&color=fff'">
                        <div class="flex-1 min-w-0">
                            <div class="flex justify-between items-baseline">
                                <h3 class="font-semibold text-gray-900 truncate chat_user_name">
                                    ${user.name}
                                </h3>
                                <span class="text-xs text-gray-500">Just now</span>
                            </div>
                            <p class="text-sm text-gray-600 truncate">
                                ${messageIcon} ${lastMessageText}
                            </p>
                        </div>
                        <span class="unread_badge ${unreadCount > 0 ? '' : 'hidden'}">${unreadCount}</span>
                    </div>
                `;

                $('.chat_list').prepend(chatTabHtml);
                
                // If this is the first chat, remove the "No chat history yet" message
                if ($('.chat_list .chat_tab').length === 1) {
                    $('.chat_list .p-4.text-center').remove();
                }
            }
        },
        error: function (xhr, status, error) {
            console.error('Error fetching chat list item:', error);
        }
    });
}

// Handle messages seen - update ALL messages from this sender
function handleMessagesSeen(data) {
    console.log('Messages seen notification received:', data);
    if (data.senderId === sending_to) {
        // Update all seen indicators to blue
        $('.sent_message').each(function() {
            const checkIcon = $(this).find('.time i.fa-check-double');
            checkIcon.addClass("text-blue-400").removeClass("text-gray-400");
            checkIcon.attr('title', 'Seen');
        });
    }
}

// Mark messages as seen in backend
function markMessagesAsSeenInBackend(messageUids, senderId) {
    $.ajax({
        url: '/mark-messages-seen',
        type: 'POST',
        data: {
            'message_uids': messageUids,
            'sender_id': senderId,
            '_token': csrf_token
        },
        success: function (response) {
            console.log('âœ… Messages marked as seen in database');
        },
        error: function (xhr, status, error) {
            console.error('Error marking messages as seen:', error);
        }
    });
}

// Notify chat opened - CRITICAL: This tells server which chat we have open
window.notifyChatOpened = function (withUserId) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('ðŸ”“ Notifying server: Chat opened with', withUserId);
        ws.send(JSON.stringify({
            type: 'chat_opened',
            withUserId: withUserId
        }));
    }
}

// Notify chat closed - CRITICAL: This tells server we closed the chat
window.notifyChatClosed = function (withUserId) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('ðŸ”’ Notifying server: Chat closed with', withUserId);
        ws.send(JSON.stringify({
            type: 'chat_closed',
            withUserId: withUserId
        }));
    }
}

function updateUnreadBadge(userId, increment) {
    if (userId === sending_to) {
        console.log('Skipping unread badge update for active chat:', userId);
        return;
    }
    
    const chatTab = $(`.chat_tab[data-userid="${userId}"]`);
    if (chatTab.length > 0) {
        const badge = chatTab.find('.unread_badge');
        const currentCount = parseInt(badge.text()) || 0;
        const newCount = currentCount + increment;

        console.log('Updating unread badge for user:', userId, 'current:', currentCount, 'new:', newCount);

        if (newCount > 0) {
            badge.removeClass('hidden').text(newCount);
        } else {
            badge.addClass('hidden').text('0');
        }
    }
}

// Update existing chat tab with new message
function updateExistingChatTab(chatTab, messageData, shouldIncrementUnread = true) {
    const isSent = messageData.senderId === user_uid;
    const isFromActiveChat = chatTab.attr('data-userid') === sending_to;

    console.log('updateExistingChatTab - shouldIncrementUnread:', shouldIncrementUnread, 'isFromActiveChat:', isFromActiveChat, 'isSent:', isSent);

    // Update last message
    let lastMessageText = '';
    let messageIcon = '';

    if (messageData.messageType === 'text') {
        lastMessageText = messageData.message.length > 40 ?
            messageData.message.substring(0, 40) + '...' :
            messageData.message;
    } else if (messageData.messageType === 'file') {
        messageIcon = '<i class="fas fa-file-alt"></i>';
        lastMessageText = isSent ? 'File sent' : 'File received';
    }

    const lastMessageHtml = messageIcon ?
        `${messageIcon} ${lastMessageText}` :
        lastMessageText;

    chatTab.find('.text-sm').html(lastMessageHtml);
    chatTab.find('.text-xs.text-gray-500').text('Just now');

    // CRITICAL: Only increment unread if NOT the active chat and NOT sent by current user
    if (shouldIncrementUnread && !isSent && !isFromActiveChat) {
        const badge = chatTab.find('.unread_badge');
        const currentCount = parseInt(badge.text()) || 0;
        const newCount = currentCount + 1;
        
        console.log('Incrementing unread badge:', currentCount, '->', newCount);
        badge.removeClass('hidden').text(newCount);
    } else {
        console.log('Skipping unread badge increment - Active chat or sent message');
    }

    // Move to top ONLY if new message (not when just opening chat)
    chatTab.prependTo('.chat_list');
}

// Update or add chat list item
function updateChatListItem(userId, messageData, shouldUpdateUnread = true) {
    const sendingToType = $('meta[name="user-type"]').attr('content') === 'wholesaler' ? 'manufacturer' : 'wholesaler';

    // Check if this is from the currently active chat
    const isFromActiveChat = userId === sending_to;
    console.log('updateChatListItem - userId:', userId, 'sending_to:', sending_to, 'isFromActiveChat:', isFromActiveChat, 'shouldUpdateUnread:', shouldUpdateUnread);

    // Check if chat tab already exists
    let chatTab = $(`.chat_tab[data-userid="${userId}"]`);

    if (chatTab.length > 0) {
        // CRITICAL: Don't increment unread if it's the active chat
        const shouldIncrementUnread = shouldUpdateUnread && !isFromActiveChat;
        updateExistingChatTab(chatTab, messageData, shouldIncrementUnread);
    } else {
        // Create new chat tab - only add unread badge if not active chat
        const shouldShowUnread = shouldUpdateUnread && !isFromActiveChat;
        createNewChatTab(userId, sendingToType, messageData, shouldShowUnread);
    }
}

// Create new chat tab
function createNewChatTab(userId, sendingToType, messageData, shouldShowUnread = true) {
    const isFromActiveChat = userId === sending_to;
    
    console.log('createNewChatTab - userId:', userId, 'sending_to:', sending_to, 'isFromActiveChat:', isFromActiveChat, 'shouldShowUnread:', shouldShowUnread);

    $.ajax({
        url: '/get-chat-list-item',
        type: 'POST',
        data: {
            'user_id': userId,
            'sending_to_type': sendingToType,
            'current_user_id': user_uid,
            '_token': csrf_token
        },
        success: function (response) {
            if (response.status === 'success') {
                const user = response.user;
                
                const isSent = messageData.senderId === user_uid;
                let lastMessageText = '';
                let messageIcon = '';

                if (messageData.messageType === 'text') {
                    lastMessageText = messageData.message.length > 40 ?
                        messageData.message.substring(0, 40) + '...' :
                        messageData.message;
                } else if (messageData.messageType === 'file') {
                    messageIcon = '<i class="fas fa-file-alt"></i>';
                    lastMessageText = isSent ? 'File sent' : 'File received';
                }

                // Only show unread badge if specified AND message is from other user AND not from active chat
                const unreadCount = (shouldShowUnread && !isSent && !isFromActiveChat) ? 1 : 0;

                console.log('Creating new chat tab with unreadCount:', unreadCount);

                const chatTabHtml = `
                    <div class="chat_tab inactive_chat_tab" data-userid="${user.id}" onclick="activateChat(this)">
                        <img src="${user.profile_picture}" alt="${user.name}"
                            class="w-12 h-12 rounded-full chat_user_img object-cover"
                            onerror="this.src='https://ui-avatars.com/api/?name=${encodeURIComponent(user.name)}&background=3b82f6&color=fff'">
                        <div class="flex-1 min-w-0">
                            <div class="flex justify-between items-baseline">
                                <h3 class="font-semibold text-gray-900 truncate chat_user_name">
                                    ${user.name}
                                </h3>
                                <span class="text-xs text-gray-500">Just now</span>
                            </div>
                            <p class="text-sm text-gray-600 truncate">
                                ${messageIcon} ${lastMessageText}
                            </p>
                        </div>
                        <span class="unread_badge ${unreadCount > 0 ? '' : 'hidden'}">${unreadCount}</span>
                    </div>
                `;

                $('.chat_list').prepend(chatTabHtml);
                
                if ($('.chat_list .chat_tab').length === 1) {
                    $('.chat_list .p-4.text-center').remove();
                }
            }
        },
        error: function (xhr, status, error) {
            console.error('Error fetching chat list item:', error);
        }
    });
}

// Handle typing indicator
function handleUserTyping(data) {
    if (data.senderId === sending_to) {
        if (data.isTyping) {
            showTypingIndicator();
        } else {
            hideTypingIndicator();
        }
    }
}

// Handle online status response
function handleOnlineStatus(data) {
    if (data.userId === sending_to) {
        updateUserOnlineStatus(data.isOnline);
    }
}

// Handle user status change
function handleUserStatusChanged(data) {
    updateChatListOnlineStatus(data.userId, data.isOnline);

    if (data.userId === sending_to) {
        updateUserOnlineStatus(data.isOnline);
    }
}

// Handle chat list update
function handleChatListUpdate(data) {
    refreshUnreadCount(data.fromUserId);
    
    // Move to top ONLY if it's not the currently active chat
    if (data.fromUserId !== sending_to) {
        moveToTopOfChatList(data.fromUserId);
    }
}

window.sendMessageWithChatUpdate = function (messageData) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'chat_message_sent',
            receiverId: sending_to,
            messageData: messageData,
            timestamp: new Date().toISOString()
        }));
    }
}

// Send typing indicator
window.sendTypingIndicator = function () {
    if (ws && ws.readyState === WebSocket.OPEN && sending_to) {
        ws.send(JSON.stringify({
            type: 'typing',
            receiverId: sending_to
        }));
    }
}

// Send stop typing indicator
window.sendStopTypingIndicator = function () {
    if (ws && ws.readyState === WebSocket.OPEN && sending_to) {
        ws.send(JSON.stringify({
            type: 'stop_typing',
            receiverId: sending_to
        }));
    }
}

// Request online status
window.requestOnlineStatus = function (userId) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'get_online_status',
            checkUserId: userId
        }));
    }
}

// UI Helper Functions
function showTypingIndicator() {
    const typingHtml = `
        <div class="typing-indicator flex items-start gap-3">
            <div class="bg-gray-200 rounded-2xl rounded-tl-none px-4 py-2">
                <div class="flex gap-1">
                    <span class="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style="animation-delay: 0s"></span>
                    <span class="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style="animation-delay: 0.2s"></span>
                    <span class="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style="animation-delay: 0.4s"></span>
                </div>
            </div>
        </div>
    `;

    $('.typing-indicator').remove();
    $('#messagesContainer').append(typingHtml);
    scrollToBottom();
}

function hideTypingIndicator() {
    $('.typing-indicator').remove();
}

function updateUserOnlineStatus(isOnline) {
    const statusText = isOnline ? 'Online now' : 'Offline';
    $('.activity').html(statusText);

    if (isOnline) {
        $('.activity').removeClass('text-gray-500').addClass('text-green-600');
    } else {
        $('.activity').removeClass('text-green-600').addClass('text-gray-500');
    }
}

function updateChatListOnlineStatus(userId, isOnline) {
    const chatTab = $(`.chat_tab[data-userid="${userId}"]`);
    if (chatTab.length > 0) {
        if (isOnline) {
            chatTab.find('.chat_user_img').addClass('ring-2 ring-green-500');
        } else {
            chatTab.find('.chat_user_img').removeClass('ring-2 ring-green-500');
        }
    }
}

function refreshUnreadCount(userId) {
    // Skip if this is the currently active chat
    if (userId === sending_to) {
        console.log('Skipping unread count refresh for active chat');
        return;
    }
    
    $.ajax({
        url: '/get-unread-count',
        type: 'POST',
        data: {
            'user_id': userId,
            '_token': csrf_token
        },
        success: function (response) {
            if (response.count > 0) {
                const badge = $(`.chat_tab[data-userid="${userId}"] .unread_badge`);
                badge.removeClass('hidden').text(response.count);
            }
        }
    });
}

function moveToTopOfChatList(userId) {
    const chatTab = $(`.chat_tab[data-userid="${userId}"]`);
    if (chatTab.length > 0) {
        chatTab.prependTo('.chat_list');
    }
}

function showConnectionStatus(status) {
    let color = 'gray';
    let text = 'Connecting...';

    if (status === 'connected') {
        color = 'green';
        text = 'Connected';
    } else if (status === 'error' || status === 'disconnected') {
        color = 'red';
        text = 'Disconnected';
    }
}

function playNotificationSound() {
    // Optional: Play notification sound
    // const audio = new Audio('/sounds/notification.mp3');
    // audio.play();
}

// Handle typing in message box
$('.message_box').on('input', function () {
    this.style.height = 'auto';
    const newHeight = Math.min(this.scrollHeight, 120);
    this.style.height = newHeight + 'px';

    if (!isTyping && sending_to) {
        isTyping = true;
        window.sendTypingIndicator();
    }

    clearTimeout(typingTimeout);

    typingTimeout = setTimeout(function () {
        isTyping = false;
        window.sendStopTypingIndicator();
    }, 1000);
});

// Update last active periodically
setInterval(function () {
    if (user_uid) {
        $.ajax({
            url: '/update-last-active',
            type: 'POST',
            data: {
                '_token': csrf_token
            },
            success: function (response) {
                // Last active updated
            }
        });
    }
}, 60000);

// Initialize WebSocket on page load
$(document).ready(function () {
    initWebSocket();
});




sserver.js:
import express from 'express';
import { WebSocketServer } from 'ws';
import http from 'http';
import cors from 'cors';

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());

const server = http.createServer(app);

const wss = new WebSocketServer({
    server,
    clientTracking: true,
    perMessageDeflate: false
});

// Store clients by user ID with additional metadata
const clients = new Map();

// Track last active timestamps
const lastActive = new Map();

// Track typing status
const typingStatus = new Map();

// Track which users have which chats open
const activeChats = new Map(); // userId => Set of chat partner IDs

// Track connection attempts to prevent spam
const connectionAttempts = new Map();
const MAX_CONNECTION_ATTEMPTS = 5;
const CONNECTION_TIMEOUT = 30000; // 30 seconds

wss.on('connection', (ws, req) => {
    const url = new URL(req.url, `ws://${req.headers.host}`);
    const userId = url.searchParams.get('userId');
    const userType = url.searchParams.get('userType');

    if (!userId || !userType) {
        ws.close(1008, 'User ID and Type required');
        return;
    }

    // Check for connection spam
    const now = Date.now();
    const attempts = connectionAttempts.get(userId) || [];
    const recentAttempts = attempts.filter(time => now - time < CONNECTION_TIMEOUT);

    if (recentAttempts.length >= MAX_CONNECTION_ATTEMPTS) {
        console.log(`Blocking connection spam from user: ${userId}`);
        ws.close(1008, 'Too many connection attempts');
        return;
    }

    // Record this connection attempt
    recentAttempts.push(now);
    connectionAttempts.set(userId, recentAttempts);

    console.log(`New client connected: ${userId} (${userType})`);

    // Close any existing connection for this user
    if (clients.has(userId)) {
        const oldClient = clients.get(userId);
        if (oldClient.ws.readyState === 1) {
            oldClient.ws.close(1000, 'New connection established');
        }
        clients.delete(userId);
    }

    clients.set(userId, {
        ws,
        userType,
        connectedAt: new Date(),
        ip: req.socket.remoteAddress
    });

    lastActive.set(userId, new Date());

    // Initialize active chats set for this user
    if (!activeChats.has(userId)) {
        activeChats.set(userId, new Set());
    }

    // Set up heartbeat
    const heartbeatInterval = setInterval(() => {
        if (ws.readyState === 1) {
            ws.ping();
        }
    }, 30000);

    ws.on('pong', () => {
        lastActive.set(userId, new Date());
    });

    try {
        ws.send(JSON.stringify({
            type: 'connected',
            message: 'Connected to chat server',
            userId: userId,
            timestamp: new Date().toISOString()
        }));
    } catch (error) {
        console.error(`Error sending connection confirmation to ${userId}:`, error);
    }

    broadcastOnlineStatus(userId);

    ws.on('message', (message) => {
        try {
            const data = JSON.parse(message);
            console.log(`ðŸ“¨ Received from ${userId}:`, data.type);

            lastActive.set(userId, new Date());

            switch (data.type) {
                case 'typing':
                    handleTyping(userId, data);
                    break;

                case 'stop_typing':
                    handleStopTyping(userId, data);
                    break;

                case 'message_seen':
                    handleMessageSeen(userId, data);
                    break;

                case 'get_online_status':
                    sendOnlineStatus(userId, data.checkUserId);
                    break;

                case 'ping':
                    ws.send(JSON.stringify({
                        type: 'pong',
                        timestamp: new Date().toISOString()
                    }));
                    break;

                case 'chat_opened':
                    handleChatOpened(userId, data);
                    break;

                case 'chat_closed':
                    handleChatClosed(userId, data);
                    break;

                case 'chat_message_sent':
                    handleChatMessageSent(userId, data);
                    break;

                default:
                    console.warn('Unknown message type:', data.type);
            }
        } catch (error) {
            console.error('Error processing message:', error);
        }
    });

    ws.on('close', (code, reason) => {
        console.log(`Client disconnected: ${userId} (Code: ${code}, Reason: ${reason})`);
        clearInterval(heartbeatInterval);
        clients.delete(userId);
        lastActive.delete(userId);
        typingStatus.delete(userId);
        activeChats.delete(userId);
        broadcastOnlineStatus(userId, true);
    });

    ws.on('error', (error) => {
        console.error(`WebSocket error for user ${userId}:`, error);
        clearInterval(heartbeatInterval);
    });

    // Handle connection timeout
    ws.on('timeout', () => {
        console.log(`Connection timeout for user ${userId}`);
        ws.close(1001, 'Connection timeout');
    });
});

// HTTP endpoint to receive notifications from Laravel backend
app.post('/api/notify', (req, res) => {
    try {
        const data = req.body;
        console.log('Received notification from backend:', data.type);

        switch (data.type) {
            case 'new_text_message':
                notifyNewTextMessage(data);
                break;

            case 'new_file_message':
                notifyNewFileMessage(data);
                break;

            case 'messages_marked_seen':
                notifyMessagesSeen(data);
                break;

            case 'user_activity':
                updateUserActivity(data);
                break;

            default:
                console.warn('Unknown notification type:', data.type);
        }

        res.json({ status: 'success', message: 'Notification processed' });
    } catch (error) {
        console.error('Error processing notification:', error);
        res.status(500).json({ status: 'error', message: error.message });
    }
});

// Enhanced active chat tracking
function isChatActive(userId, withUserId) {
    if (!activeChats.has(userId)) {
        return false;
    }

    const isActive = activeChats.get(userId).has(withUserId);
    console.log(`Chat active check: ${userId} with ${withUserId} = ${isActive}`);

    return isActive;
}

// Handle chat opened - track active chat
function handleChatOpened(userId, data) {
    const { withUserId } = data;

    if (!withUserId) return;

    // Add to active chats
    if (!activeChats.has(userId)) {
        activeChats.set(userId, new Set());
    }
    activeChats.get(userId).add(withUserId);

    console.log(`ðŸ”“ User ${userId} opened chat with ${withUserId}`);
}

// Handle chat closed - remove from active chats
function handleChatClosed(userId, data) {
    const { withUserId } = data;

    if (!withUserId) return;

    // Remove from active chats
    if (activeChats.has(userId)) {
        activeChats.get(userId).delete(withUserId);
    }

    console.log(`ðŸ”’ User ${userId} closed chat with ${withUserId}`);
}

function handleChatMessageSent(senderId, data) {
    const { receiverId, messageData } = data;
    
    if (!receiverId) return;

    console.log(`ðŸ’¬ User ${senderId} sent message to ${receiverId}`);
    
    // Update sender's own chat list across all their devices
    if (clients.has(senderId)) {
        const sender = clients.get(senderId);
        if (sender.ws.readyState === 1) {
            try {
                sender.ws.send(JSON.stringify({
                    type: 'update_chat_list',
                    fromUserId: receiverId,
                    timestamp: new Date().toISOString(),
                    isSentMessage: true
                }));
                console.log(`âœ… Chat list updated for sender ${senderId}`);
            } catch (error) {
                console.error(`Failed to update chat list for sender ${senderId}:`, error);
            }
        }
    }
    
    // Also update receiver's chat list if they're online
    if (clients.has(receiverId)) {
        const receiver = clients.get(receiverId);
        if (receiver.ws.readyState === 1) {
            try {
                receiver.ws.send(JSON.stringify({
                    type: 'update_chat_list',
                    fromUserId: senderId,
                    timestamp: new Date().toISOString(),
                    isSentMessage: true
                }));
                console.log(`âœ… Chat list updated for receiver ${receiverId}`);
            } catch (error) {
                console.error(`Failed to update chat list for receiver ${receiverId}:`, error);
            }
        }
    }
}

// Notify about new text message (called by Laravel after DB save)
async function notifyNewTextMessage(data) {
    const { senderId, receiverId, message, messageUid, timestamp } = data;

    if (!receiverId || !message) {
        console.warn('Invalid message data');
        return;
    }

    // Check if receiver is online (either connected or active within 15 minutes)
    const receiverIsOnline = isUserOnline(receiverId);
    console.log(`ðŸ“¨ Text message from ${senderId} to ${receiverId}, receiver online: ${receiverIsOnline}`);

    // Get sender info for notification
    const senderInfo = await getUserInfoForNotification(senderId, getSenderType(senderId));

    // Check if receiver has chat open with sender
    const chatIsOpen = isChatActive(receiverId, senderId);
    console.log(`Chat open status: ${receiverId} with ${senderId} = ${chatIsOpen}`);

    // Send to receiver if they have an active WebSocket connection
    if (clients.has(receiverId)) {
        const receiver = clients.get(receiverId);
        if (receiver.ws.readyState === 1) {
            const messageData = {
                type: 'new_message',
                messageType: 'text',
                senderId: senderId,
                senderName: senderInfo.senderName,
                profilePicture: senderInfo.profilePicture,
                receiverId: receiverId,
                message: message,
                messageUid: messageUid,
                timestamp: timestamp,
                seen: chatIsOpen,
                chatIsOpen: chatIsOpen
            };

            try {
                receiver.ws.send(JSON.stringify(messageData));
                console.log(`Text message notification sent to ${receiverId}`);
            } catch (error) {
                console.error(`Failed to send text message to ${receiverId}:`, error);
                clients.delete(receiverId); // Remove broken connection
            }

            // Update chat list for receiver
            updateChatList(receiverId, senderId, {
                message: message,
                messageType: 'text',
                timestamp: timestamp
            });

            // If chat is open, automatically mark as seen
            if (chatIsOpen) {
                console.log(`ðŸ‘ï¸ Auto-marking text message ${messageUid} as seen`);

                // Notify sender that message was seen
                setTimeout(() => {
                    if (clients.has(senderId)) {
                        const sender = clients.get(senderId);
                        if (sender.ws.readyState === 1) {
                            try {
                                sender.ws.send(JSON.stringify({
                                    type: 'messages_seen',
                                    senderId: receiverId,
                                    messageUids: [messageUid],
                                    timestamp: new Date().toISOString(),
                                    autoSeen: true
                                }));
                                console.log(`Auto-seen notification sent to sender ${senderId}`);
                            } catch (error) {
                                console.error(`Failed to send auto-seen to ${senderId}:`, error);
                            }
                        }
                    }
                }, 100);
            }
        }
    } else if (receiverIsOnline) {
        console.log(`Receiver ${receiverId} is online (recent activity) but not connected via WebSocket`);
        // User is considered online due to recent activity but doesn't have active WebSocket
        // The notification will be shown when they next load the page or reconnect
    } else {
        console.log(`Receiver ${receiverId} is offline, message stored for later`);
    }

    // Update sender's chat list regardless of receiver's online status
    if (clients.has(senderId)) {
        const sender = clients.get(senderId);
        if (sender.ws.readyState === 1) {
            try {
                sender.ws.send(JSON.stringify({
                    type: 'update_chat_list',
                    fromUserId: receiverId,
                    timestamp: new Date().toISOString(),
                    isSentMessage: true,
                    messageData: {
                        message: message,
                        messageType: 'text',
                        timestamp: timestamp
                    }
                }));
                console.log(`Chat list updated for sender ${senderId}`);
            } catch (error) {
                console.error(`Failed to update chat list for sender ${senderId}:`, error);
            }
        }
    }
}

// Notify about new file message (called by Laravel after DB save)
async function notifyNewFileMessage(data) {
    const { senderId, receiverId, fileData, messageText, messageUid, timestamp } = data;

    if (!receiverId || !fileData) {
        console.warn('Invalid file message data');
        return;
    }

    // Check if receiver is online (either connected or active within 15 minutes)
    const receiverIsOnline = isUserOnline(receiverId);
    console.log(`ðŸ“Ž File message from ${senderId} to ${receiverId}, receiver online: ${receiverIsOnline}`);

    // Get sender info for notification
    const senderInfo = await getUserInfoForNotification(senderId, getSenderType(senderId));

    // Check if receiver has chat open with sender
    const chatIsOpen = isChatActive(receiverId, senderId);

    // Send to receiver if they have an active WebSocket connection
    if (clients.has(receiverId)) {
        const receiver = clients.get(receiverId);
        if (receiver.ws.readyState === 1) {
            const messageData = {
                type: 'new_message',
                messageType: 'file',
                senderId: senderId,
                senderName: senderInfo.senderName,
                profilePicture: senderInfo.profilePicture,
                receiverId: receiverId,
                fileData: fileData,
                messageText: messageText || '',
                messageUid: messageUid,
                timestamp: timestamp,
                seen: chatIsOpen,
                chatIsOpen: chatIsOpen
            };

            try {
                receiver.ws.send(JSON.stringify(messageData));
                console.log(`File message notification sent to ${receiverId}`);
            } catch (error) {
                console.error(`Failed to send file message to ${receiverId}:`, error);
                clients.delete(receiverId); // Remove broken connection
            }

            // Update chat list for receiver
            updateChatList(receiverId, senderId, {
                message: messageText || 'File',
                messageType: 'file',
                timestamp: timestamp
            });

            // If chat is open, automatically mark as seen
            if (chatIsOpen) {
                console.log(`ðŸ‘ï¸ Auto-marking file message ${messageUid} as seen`);

                // Notify sender that message was seen
                setTimeout(() => {
                    if (clients.has(senderId)) {
                        const sender = clients.get(senderId);
                        if (sender.ws.readyState === 1) {
                            try {
                                sender.ws.send(JSON.stringify({
                                    type: 'messages_seen',
                                    senderId: receiverId,
                                    messageUids: [messageUid],
                                    timestamp: new Date().toISOString(),
                                    autoSeen: true
                                }));
                                console.log(`âœ… Auto-seen notification sent to sender ${senderId}`);
                            } catch (error) {
                                console.error(`Failed to send auto-seen to ${senderId}:`, error);
                            }
                        }
                    }
                }, 100);
            }
        }
    } else if (receiverIsOnline) {
        console.log(`Receiver ${receiverId} is online (recent activity) but not connected via WebSocket`);
    } else {
        console.log(`Receiver ${receiverId} is offline, file message stored for later`);
    }

    // Update sender's chat list regardless of receiver's online status
    if (clients.has(senderId)) {
        const sender = clients.get(senderId);
        if (sender.ws.readyState === 1) {
            try {
                sender.ws.send(JSON.stringify({
                    type: 'update_chat_list',
                    fromUserId: receiverId,
                    timestamp: new Date().toISOString(),
                    isSentMessage: true,
                    messageData: {
                        message: messageText || 'File',
                        messageType: 'file',
                        timestamp: timestamp
                    }
                }));
                console.log(`âœ… Chat list updated for sender ${senderId}`);
            } catch (error) {
                console.error(`Failed to update chat list for sender ${senderId}:`, error);
            }
        }
    }
}

// Notify about messages being seen (called by Laravel)
function notifyMessagesSeen(data) {
    const { senderId, receiverId, messageUids } = data;

    if (!receiverId || !messageUids) {
        console.warn('Invalid messages seen data');
        return;
    }

    console.log(`ðŸ‘€ Notifying ${receiverId} that messages were seen by ${senderId}`);

    // Notify the original sender that their messages were seen
    if (clients.has(receiverId)) {
        const receiver = clients.get(receiverId);
        if (receiver.ws.readyState === 1) {
            try {
                receiver.ws.send(JSON.stringify({
                    type: 'messages_seen',
                    senderId: senderId,
                    messageUids: messageUids,
                    timestamp: new Date().toISOString()
                }));
                console.log(`âœ… Messages seen notification sent to ${receiverId}`);
            } catch (error) {
                console.error(`Failed to send messages seen to ${receiverId}:`, error);
                clients.delete(receiverId);
            }
        }
    }
}

// Update the lastActive tracking to be more robust
function updateUserActivity(data) {
    const { userId, timestamp } = data;
    lastActive.set(userId, new Date());
    console.log(`ðŸ”„ User activity updated: ${userId}`);

    // Broadcast online status if user was previously offline
    if (!clients.has(userId)) {
        broadcastOnlineStatus(userId, false);
    }
}

// Enhanced isUserOnline function
function isUserOnline(userId) {
    if (clients.has(userId)) {
        const client = clients.get(userId);
        if (client.ws.readyState === 1) {
            return true;
        }
    }

    // Check last activity - user is online if active within 15 minutes
    const lastActivity = lastActive.get(userId);
    if (lastActivity) {
        const minutesSinceLastActivity = (new Date() - lastActivity) / (1000 * 60);
        return minutesSinceLastActivity <= 15; // 15-minute window
    }

    return false;
}

// Handle typing indicator
function handleTyping(senderId, data) {
    const { receiverId } = data;

    if (!receiverId) return;

    typingStatus.set(`${senderId}_${receiverId}`, true);

    if (clients.has(receiverId)) {
        const receiver = clients.get(receiverId);
        if (receiver.ws.readyState === 1) {
            try {
                receiver.ws.send(JSON.stringify({
                    type: 'user_typing',
                    senderId: senderId,
                    isTyping: true
                }));
            } catch (error) {
                console.error(`Failed to send typing indicator to ${receiverId}:`, error);
            }
        }
    }
}

// Handle stop typing
function handleStopTyping(senderId, data) {
    const { receiverId } = data;

    if (!receiverId) return;

    typingStatus.delete(`${senderId}_${receiverId}`);

    if (clients.has(receiverId)) {
        const receiver = clients.get(receiverId);
        if (receiver.ws.readyState === 1) {
            try {
                receiver.ws.send(JSON.stringify({
                    type: 'user_typing',
                    senderId: senderId,
                    isTyping: false
                }));
            } catch (error) {
                console.error(`Failed to send stop typing to ${receiverId}:`, error);
            }
        }
    }
}

// Handle message seen (sent from client)
function handleMessageSeen(senderId, data) {
    const { receiverId, messageUids } = data;

    if (!receiverId) return;

    console.log(`ðŸ‘€ User ${senderId} marked messages as seen for ${receiverId}`);

    // Notify the sender that their messages were seen
    if (clients.has(receiverId)) {
        const receiver = clients.get(receiverId);
        if (receiver.ws.readyState === 1) {
            try {
                receiver.ws.send(JSON.stringify({
                    type: 'messages_seen',
                    senderId: senderId,
                    messageUids: messageUids,
                    timestamp: new Date().toISOString()
                }));
            } catch (error) {
                console.error(`Failed to send message seen to ${receiverId}:`, error);
            }
        }
    }
}

// Enhanced update chat list function
function updateChatList(userId, newMessageFrom, messageData = null) {
    if (clients.has(userId)) {
        const user = clients.get(userId);
        if (user.ws.readyState === 1) {
            try {
                const payload = {
                    type: 'update_chat_list',
                    fromUserId: newMessageFrom,
                    timestamp: new Date().toISOString()
                };

                // Add message data if available for creating new chat tabs
                if (messageData) {
                    payload.messageData = messageData;
                    payload.senderId = newMessageFrom;
                }

                user.ws.send(JSON.stringify(payload));
                console.log(`âœ… Chat list updated for ${userId} from ${newMessageFrom}`);
            } catch (error) {
                console.error(`Failed to update chat list for ${userId}:`, error);
            }
        }
    }
}

// Send online status for specific user
function sendOnlineStatus(requesterId, checkUserId) {
    if (!clients.has(requesterId)) return;

    const requester = clients.get(requesterId);
    const isOnline = clients.has(checkUserId);

    let lastActiveTime = null;
    if (!isOnline && lastActive.has(checkUserId)) {
        lastActiveTime = lastActive.get(checkUserId).toISOString();
    }

    if (requester.ws.readyState === 1) {
        try {
            requester.ws.send(JSON.stringify({
                type: 'online_status',
                userId: checkUserId,
                isOnline: isOnline,
                lastActive: lastActiveTime,
                timestamp: new Date().toISOString()
            }));
        } catch (error) {
            console.error(`Failed to send online status to ${requesterId}:`, error);
        }
    }
}

// Broadcast online status change
function broadcastOnlineStatus(userId, isDisconnect = false) {
    const payload = {
        type: 'user_status_changed',
        userId: userId,
        isOnline: !isDisconnect,
        timestamp: new Date().toISOString()
    };

    clients.forEach((client, clientId) => {
        if (client.ws.readyState === 1 && clientId !== userId) {
            try {
                client.ws.send(JSON.stringify(payload));
            } catch (error) {
                console.error(`Failed to broadcast status to ${clientId}:`, error);
            }
        }
    });
}

// Helper function to determine sender type based on ID pattern
function getSenderType(userId) {
    if (userId.startsWith('WS_') || userId.includes('wholesaler')) {
        return 'wholesaler';
    } else if (userId.startsWith('MN_') || userId.includes('manufacturer')) {
        return 'manufacturer';
    }
    return 'unknown';
}

// Enhanced function to get user info for notifications
async function getUserInfoForNotification(userId, userType) {
    try {
        let senderName = 'User';
        let profilePicture = null;

        // Based on your user ID patterns
        if (userType === 'wholesaler') {
            senderName = 'Wholesaler';
        } else if (userType === 'manufacturer') {
            senderName = 'Manufacturer';
        }

        // Generate avatar
        profilePicture = `https://ui-avatars.com/api/?name=${encodeURIComponent(senderName)}&background=3b82f6&color=fff`;

        return {
            senderName: senderName,
            profilePicture: profilePicture
        };

    } catch (error) {
        console.error('Error getting user info for notification:', error);
        return {
            senderName: 'User',
            profilePicture: 'https://ui-avatars.com/api/?name=User&background=3b82f6&color=fff'
        };
    }
}

// Clean up old connection attempts periodically
setInterval(() => {
    const now = Date.now();
    connectionAttempts.forEach((attempts, userId) => {
        const recentAttempts = attempts.filter(time => now - time < CONNECTION_TIMEOUT);
        if (recentAttempts.length === 0) {
            connectionAttempts.delete(userId);
        } else {
            connectionAttempts.set(userId, recentAttempts);
        }
    });
}, 60000); // Clean every minute

// Heartbeat to detect inactive connections
setInterval(() => {
    const now = new Date();
    const inactiveThreshold = 1000 * 60 * 15; // 15 minutes

    clients.forEach((client, userId) => {
        const lastActiveTime = lastActive.get(userId);
        if (lastActiveTime && (now - lastActiveTime) > inactiveThreshold) {
            console.log(`ðŸ’¤ Closing inactive connection for ${userId}`);
            try {
                client.ws.close(1000, 'Inactive connection');
            } catch (error) {
                console.error(`Error closing inactive connection for ${userId}:`, error);
            }
        }
    });
}, 1000 * 60); // Check every minute

// Health check endpoint
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        connectedClients: clients.size,
        activeChats: activeChats.size,
        timestamp: new Date().toISOString(),
        memoryUsage: process.memoryUsage(),
        uptime: process.uptime()
    });
});

// Debug endpoint to see active chats
app.get('/debug/active-chats', (req, res) => {
    const activeChatsObj = {};
    activeChats.forEach((chatSet, userId) => {
        activeChatsObj[userId] = Array.from(chatSet);
    });

    res.json({
        activeChats: activeChatsObj,
        connectedClients: Array.from(clients.keys()),
        timestamp: new Date().toISOString()
    });
});

// Server status endpoint
app.get('/status', (req, res) => {
    res.json({
        server: 'WebSocket Chat Server',
        status: 'running',
        port: port,
        connectedClients: clients.size,
        uptime: process.uptime(),
        timestamp: new Date().toISOString()
    });
});

// Start server
server.listen(port, '0.0.0.0', () => {
    console.log(`WebSocket server running on ws://localhost:${port}`);
    console.log(`HTTP API available at http://localhost:${port}`);
    console.log(`Health check available at http://localhost:${port}/health`);
    console.log(`Server status at http://localhost:${port}/status`);
});

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('Shutting down WebSocket server...');

    clients.forEach((client) => {
        try {
            client.ws.close(1001, 'Server shutting down');
        } catch (error) {
            console.error('Error closing client connection:', error);
        }
    });

    wss.close(() => {
        server.close(() => {
            console.log('âœ… WebSocket server closed gracefully');
            process.exit(0);
        });
    });
});




Now here, if sender opened the message with a specific receiver; same way if the receiver also had the message box open with same sender, then all message among them will be as seen = 1; and thus no badge update and showing of badge will happen, and every message will be blue ticked (which is marked as seen).
Chat list will move to up on every sent/received message.

But if the sender is not whom with whom the receiver opening the message, then it will be updated normally.

means like 'A' is chatting with 'B'. 
A has messages with C, D & F.
Now A sent a message to B.
B has opened the message.
And styed in the chatbox with A, then all messages will be marked as seen = 1; 
as basically A and B both are seeing the messages.
But if B or A anyone is not in the appropriate message/chat with opened, then seen = 0;

So do this please.

The JS work is done, just update the backend as well, thus when seen happens it also update in backend.
Currently backend seen update not happening here.